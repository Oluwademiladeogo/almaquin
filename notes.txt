import { Request, Response } from "express";
import { University } from "../models/university";

export const getAllUniNamesController = async (req: Request, res: Response) => {
  try {
    //gets all university names and returns then as an array
    const universities = await University.find({}, { name: 1 });
    const universityNames = universities.map((university) => university.name);

    res.status(200).json({ universities: universityNames });
  } catch (error) {
    console.error("Error fetching universities:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
};
I changed what you sent me to this
now generate the universities model. the model looks like this:
the university has name, picture(this is a url to the cloud platform), email, overview(plain text field), undergraduate and postgraduate. 
controller to get universities, add universities, delete universities, update universities:just the name hopefully

controller to get university details, add, delete, update the details.

when it comes to university details store as this: //basic info and inside it, name, website, logo, location
additional info(will be provided by the owners)// instead of this we'll just retrieve name, email and overview as basic info, profile, uni website link
useful links(will be provided by owners with title)

in teh first page, get universities. whn you get universities and click on one,
yuo go to the second page where you get all three separately and send them as one json file
get first part overview, academics, programs and certs. second part, undergrad: add topic, then the user can add under topic if they want to nest everything, properties, edit all as they like then nested in properties, can add comments
same as pg just change something little.



import { Request, Response } from 'express';
import Prayer from '../models/prayers';
import { IPrayerDoc } from '../types';
import { validatePrayer, validatePrayerUpdate } from '../validators/prayer';
import mongoose from 'mongoose';

export const createPrayer = async (req: Request, res: Response): Promise<Response> => {
    const { title, url, startDate, endDate, frequency } = req.body;

    const { error } = validatePrayer({ title, url, startDate, endDate, frequency });

    if (error) {
        return res.status(400).json({ success: false, details: error.details[0].message });
    }

    const newPrayer = new Prayer({
        title,
        url,
        startDate,
        endDate,
        frequency,
    });

    const savedPrayer = await newPrayer.save();

    return res.status(201).json({ success: true, prayer: savedPrayer });
};

export const getAllPrayers = async (_req: Request, res: Response): Promise<Response> => {
    const prayers = await Prayer.find();
    return res.status(200).json({ success: true, prayers });
};

export const getPrayerById = async (req: Request, res: Response): Promise<Response> => {
    const { id } = req.params;

    if (!mongoose.isObjectIdOrHexString(id)) return res.status(400).send({ success: false, details: `${id} is not a valid ID` });

    const prayer = await Prayer.findById(id);

    if (!prayer) {
        return res.status(404).json({ success: false, details: 'Prayer not found' });
    }

    return res.status(200).json({ success: true, prayer });
};

export const updatePrayerById = async (req: Request, res: Response): Promise<Response> => {
    const { id } = req.params;

    if (!mongoose.isObjectIdOrHexString(id)) return res.status(400).send({success: false, details: `${id} is not a valid ID`});

    const updateFields: Partial<IPrayerDoc> = req.body;
    const { error } = validatePrayerUpdate(updateFields);

    if (error) {
      return res.status(400).json({ success: false, error: error.details[0].message });
    }

    const { title, url, startDate, endDate, frequency }: Partial<IPrayerDoc> = req.body;

    const updatedPrayer = await Prayer.findByIdAndUpdate(
      id,
      { title, url, startDate, endDate, frequency },
      { new: true }
    );

    if (!updatedPrayer) {
      return res.status(404).json({ success: false, error: 'Prayer not found' });
    }

    return res.status(200).json({ success: true, prayer: updatedPrayer });
};


export const deletePrayerById = async (req: Request, res: Response): Promise<Response> => {
    const { id } = req.params;

    if (!mongoose.isObjectIdOrHexString(id)) return res.status(400).send({success: false, details: `${id} is not a valid ID`});

    const deletedPrayer = await Prayer.findByIdAndDelete(id);

    if (!deletedPrayer) {
      return res.status(404).json({ success: false, error: 'Prayer not found' });
    }

    return res.status(200).json({ success: true });
};
